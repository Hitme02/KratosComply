"""Additional vulnerability detection functions for industry-grade security scanning.

This module contains advanced vulnerability detection functions that extend
the core detectors with additional OWASP Top 10 and CWE coverage.
"""
from __future__ import annotations

from pathlib import Path
import re
import logging

from pathlib import Path
import re
import logging

from .findings import RawFinding

logger = logging.getLogger(__name__)


def _iter_files(root: Path):
    """Iterate over all files in the workspace, excluding skipped paths."""
    from .detectors import _iter_files as _iter_files_impl
    return _iter_files_impl(root)


def _should_skip(path: Path) -> bool:
    """Skip excluded directories and files."""
    from .detectors import _should_skip as _should_skip_impl
    return _should_skip_impl(path)


def _relative_path(path: Path, root: Path) -> str:
    """Get relative path from root."""
    from .detectors import _relative_path as _relative_path_impl
    return _relative_path_impl(path, root)

logger = logging.getLogger(__name__)


def _scan_xxe_vulnerabilities(root: Path) -> list[RawFinding]:
    """Detect XML External Entity (XXE) injection vulnerabilities."""
    findings: list[RawFinding] = []
    
    # XXE patterns
    xxe_patterns = [
        # Java: DocumentBuilder, SAXParser without XXE protection
        (r'DocumentBuilderFactory\s*\.\s*newInstance\(\)', "DocumentBuilderFactory without XXE protection (Java)"),
        (r'SAXParserFactory\s*\.\s*newInstance\(\)', "SAXParserFactory without XXE protection (Java)"),
        (r'XMLInputFactory\s*\.\s*newInstance\(\)', "XMLInputFactory without XXE protection (Java)"),
        (r'TransformerFactory\s*\.\s*newInstance\(\)', "TransformerFactory without XXE protection (Java)"),
        # Python: xml.etree.ElementTree, lxml without XXE protection
        (r'xml\.etree\.ElementTree\.parse\(', "ElementTree.parse() without XXE protection (Python)"),
        (r'lxml\.etree\.parse\(', "lxml.etree.parse() without XXE protection (Python)"),
        (r'xml\.dom\.minidom\.parse\(', "minidom.parse() without XXE protection (Python)"),
        # PHP: SimpleXML, DOMDocument without XXE protection
        (r'new\s+SimpleXMLElement\s*\(', "SimpleXMLElement without XXE protection (PHP)"),
        (r'DOMDocument\s*->\s*loadXML\s*\(', "DOMDocument->loadXML() without XXE protection (PHP)"),
        # Node.js: xml2js, fast-xml-parser without XXE protection
        (r'xml2js\.parseString\s*\(', "xml2js.parseString() without XXE protection (Node.js)"),
        (r'fast-xml-parser.*parse\s*\(', "fast-xml-parser without XXE protection (Node.js)"),
    ]
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        for pattern, description in xxe_patterns:
            for line_no, line in enumerate(lines, start=1):
                if re.search(pattern, line, re.IGNORECASE):
                    stripped = line.strip()
                    if stripped.startswith(('//', '/*', '*', '#', '--')):
                        continue
                    
                    # Check if XXE protection exists nearby
                    context_start = max(0, line_no - 10)
                    context_end = min(len(lines), line_no + 10)
                    context = '\n'.join(lines[context_start:context_end]).lower()
                    
                    # Check for XXE protection patterns
                    protection_patterns = [
                        'setfeature', 'setexpandentityreferences', 'setexternalgeneralentities',
                        'setexternalparameterentities', 'disallowdoctypedecl', 'externalgeneralentities',
                        'externalparameterentities', 'loaddtd', 'resolveexternals', 'noent',
                        'xml_parser_set_option.*xml_option_no_ent'
                    ]
                    
                    if any(pp in context for pp in protection_patterns):
                        continue  # XXE protection found
                    
                    findings.append(RawFinding(
                        type="potential_sql_injection",  # Use same type for injection vulnerabilities
                        file=_relative_path(file_path, root),
                        line=line_no,
                        snippet=line.strip()[:200],
                        severity="high",
                        confidence=0.85,
                        metadata={"issue": description, "vulnerability": "xxe", "control_id": "SOC2-CC6.1"}
                    ))
                    break
    
    return findings


def _scan_ssrf_vulnerabilities(root: Path) -> list[RawFinding]:
    """Detect Server-Side Request Forgery (SSRF) vulnerabilities."""
    findings: list[RawFinding] = []
    
    # SSRF patterns
    ssrf_patterns = [
        # Python: urllib, requests with user input
        (r'urllib\.(urlopen|request)\([^)]*[a-zA-Z_]+[^)]*\)', "urllib with user input (SSRF risk)"),
        (r'requests\.(get|post|put|delete)\([^)]*[a-zA-Z_]+[^)]*\)', "requests with user input (SSRF risk)"),
        (r'httpx\.(get|post|put|delete)\([^)]*[a-zA-Z_]+[^)]*\)', "httpx with user input (SSRF risk)"),
        # Node.js: http, https, axios with user input
        (r'http\.(get|request)\([^)]*[a-zA-Z_]+[^)]*\)', "http.get() with user input (SSRF risk)"),
        (r'https\.(get|request)\([^)]*[a-zA-Z_]+[^)]*\)', "https.get() with user input (SSRF risk)"),
        (r'axios\.(get|post|put|delete)\([^)]*[a-zA-Z_]+[^)]*\)', "axios with user input (SSRF risk)"),
        # PHP: file_get_contents, curl with user input
        (r'file_get_contents\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE)', "file_get_contents() with user input (SSRF risk)"),
        (r'curl_exec\s*\(\s*curl_init\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE)', "curl_exec() with user input (SSRF risk)"),
        # Java: URL, HttpURLConnection with user input
        (r'new\s+URL\s*\(\s*[a-zA-Z_]+\s*\)', "new URL() with variable (SSRF risk)"),
        (r'HttpURLConnection.*openConnection\s*\(\s*[a-zA-Z_]+\s*\)', "HttpURLConnection with variable (SSRF risk)"),
    ]
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        for pattern, description in ssrf_patterns:
            for line_no, line in enumerate(lines, start=1):
                if re.search(pattern, line, re.IGNORECASE):
                    stripped = line.strip()
                    if stripped.startswith(('//', '/*', '*', '#', '--')):
                        continue
                    
                    # Check if URL validation exists nearby
                    context_start = max(0, line_no - 10)
                    context_end = min(len(lines), line_no + 10)
                    context = '\n'.join(lines[context_start:context_end]).lower()
                    
                    # Check for SSRF protection patterns
                    protection_patterns = [
                        'whitelist', 'allowlist', 'url.*validate', 'url.*sanitize',
                        'localhost', '127.0.0.1', 'private.*ip', 'internal.*network'
                    ]
                    
                    if any(pp in context for pp in protection_patterns):
                        continue  # SSRF protection found
                    
                    findings.append(RawFinding(
                        type="insecure_acl",
                        file=_relative_path(file_path, root),
                        line=line_no,
                        snippet=line.strip()[:200],
                        severity="high",
                        confidence=0.8,
                        metadata={"issue": description, "vulnerability": "ssrf", "control_id": "SOC2-CC6.1"}
                    ))
                    break
    
    return findings


def _scan_insecure_deserialization(root: Path) -> list[RawFinding]:
    """Detect insecure deserialization vulnerabilities."""
    findings: list[RawFinding] = []
    
    # Insecure deserialization patterns
    deserialization_patterns = [
        # Python: pickle, yaml.load with user input
        (r'pickle\.(loads?|load)\([^)]*[a-zA-Z_]+[^)]*\)', "pickle deserialization with user input (Python)"),
        (r'yaml\.load\s*\([^)]*[a-zA-Z_]+[^)]*\)', "yaml.load() with user input (Python - unsafe)"),
        (r'marshal\.loads?\s*\([^)]*[a-zA-Z_]+[^)]*\)', "marshal.loads() with user input (Python)"),
        # Java: ObjectInputStream, readObject with user input
        (r'ObjectInputStream.*readObject\s*\(', "ObjectInputStream.readObject() (Java - insecure deserialization)"),
        (r'readObject\s*\(', "readObject() method (Java - insecure deserialization)"),
        # .NET: BinaryFormatter, SoapFormatter
        (r'BinaryFormatter.*Deserialize\s*\(', "BinaryFormatter.Deserialize() (.NET - insecure)"),
        (r'SoapFormatter.*Deserialize\s*\(', "SoapFormatter.Deserialize() (.NET - insecure)"),
        # Node.js: eval, Function constructor with user input
        (r'eval\s*\(\s*[a-zA-Z_]+', "eval() with variable (Node.js - insecure)"),
        (r'Function\s*\(\s*[a-zA-Z_]+', "Function() constructor with variable (Node.js - insecure)"),
        # PHP: unserialize with user input
        (r'unserialize\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE)', "unserialize() with user input (PHP)"),
    ]
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        for pattern, description in deserialization_patterns:
            for line_no, line in enumerate(lines, start=1):
                if re.search(pattern, line, re.IGNORECASE):
                    stripped = line.strip()
                    if stripped.startswith(('//', '/*', '*', '#', '--')):
                        continue
                    
                    findings.append(RawFinding(
                        type="potential_sql_injection",  # Use same type for injection vulnerabilities
                        file=_relative_path(file_path, root),
                        line=line_no,
                        snippet=line.strip()[:200],
                        severity="critical",
                        confidence=0.9,
                        metadata={"issue": description, "vulnerability": "insecure_deserialization", "control_id": "SOC2-CC6.1"}
                    ))
                    break
    
    return findings


def _scan_path_traversal(root: Path) -> list[RawFinding]:
    """Detect path traversal vulnerabilities."""
    findings: list[RawFinding] = []
    
    # Path traversal patterns
    path_traversal_patterns = [
        # File operations with user input containing ../
        (r'open\s*\(\s*[^)]*\.\./', "open() with ../ (path traversal)"),
        (r'File\.(read|write|delete|exists)\s*\([^)]*\.\./', "File operation with ../ (path traversal)"),
        (r'readFile\s*\([^)]*\.\./', "readFile() with ../ (path traversal)"),
        (r'file_get_contents\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE).*\.\./', "file_get_contents() with ../ (path traversal)"),
        (r'new\s+File\s*\([^)]*\.\./', "new File() with ../ (path traversal)"),
    ]
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        for pattern, description in path_traversal_patterns:
            for line_no, line in enumerate(lines, start=1):
                if re.search(pattern, line, re.IGNORECASE):
                    stripped = line.strip()
                    if stripped.startswith(('//', '/*', '*', '#', '--')):
                        continue
                    
                    # Check if path sanitization exists nearby
                    context_start = max(0, line_no - 5)
                    context_end = min(len(lines), line_no + 5)
                    context = '\n'.join(lines[context_start:context_end]).lower()
                    
                    # Check for path sanitization
                    sanitization_patterns = [
                        'basename', 'realpath', 'abspath', 'normalize', 'canonicalize',
                        'path.*join', 'os.path.join', 'path.resolve', 'sanitize'
                    ]
                    
                    if any(sp in context for sp in sanitization_patterns):
                        continue  # Path sanitization found
                    
                    findings.append(RawFinding(
                        type="insecure_acl",
                        file=_relative_path(file_path, root),
                        line=line_no,
                        snippet=line.strip()[:200],
                        severity="high",
                        confidence=0.85,
                        metadata={"issue": description, "vulnerability": "path_traversal", "control_id": "SOC2-CC6.1"}
                    ))
                    break
    
    return findings


def _scan_race_conditions(root: Path) -> list[RawFinding]:
    """Detect potential race condition vulnerabilities."""
    findings: list[RawFinding] = []
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        # Check for TOCTOU patterns (multi-line)
        for line_no, line in enumerate(lines, start=1):
            # Check if line has exists() check
            if re.search(r'\.exists\s*\(|File\.exists|fs\.exists', line, re.IGNORECASE):
                # Check next few lines for file operations
                for next_line_no in range(line_no + 1, min(len(lines), line_no + 5)):
                    next_line = lines[next_line_no]
                    if re.search(r'open\s*\(|File\.(read|write|delete)|readFile|writeFile', next_line, re.IGNORECASE):
                        findings.append(RawFinding(
                            type="insecure_acl",
                            file=_relative_path(file_path, root),
                            line=line_no,
                            snippet=f"{line.strip()[:100]} ... {next_line.strip()[:100]}",
                            severity="medium",
                            confidence=0.7,
                            metadata={"issue": "TOCTOU: exists() check followed by file operation (race condition)", "vulnerability": "race_condition", "control_id": "SOC2-CC6.1"}
                        ))
                        break
    
    return findings


def _scan_crypto_misuse(root: Path) -> list[RawFinding]:
    """Detect cryptographic misuse and weak implementations."""
    findings: list[RawFinding] = []
    
    # Crypto misuse patterns
    crypto_misuse_patterns = [
        # Weak random number generators
        (r'Math\.random\s*\(', "Math.random() - insecure random (JavaScript)"),
        (r'random\.randint\s*\(', "random.randint() - insecure random (Python)"),
        (r'new\s+Random\s*\(\)', "new Random() - insecure random (Java)"),
        # Hardcoded IVs/nonces
        (r'iv\s*=\s*["\'][^"\']{1,16}["\']', "Hardcoded IV (initialization vector)"),
        (r'nonce\s*=\s*["\'][^"\']{1,16}["\']', "Hardcoded nonce"),
        # Weak key derivation
        (r'PBKDF2.*iterations\s*=\s*[0-9]{1,3}\b', "PBKDF2 with low iteration count"),
        (r'bcrypt.*rounds\s*=\s*[0-4]\b', "bcrypt with low rounds"),
    ]
    
    for file_path in _iter_files(root):
        if _should_skip(file_path):
            continue
        
        if file_path.suffix not in (".py", ".js", ".ts", ".java", ".cs", ".php", ".rb", ".go"):
            continue
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        
        lines = content.splitlines()
        
        for pattern, description in crypto_misuse_patterns:
            for line_no, line in enumerate(lines, start=1):
                if re.search(pattern, line, re.IGNORECASE):
                    stripped = line.strip()
                    if stripped.startswith(('//', '/*', '*', '#', '--')):
                        continue
                    
                    findings.append(RawFinding(
                        type="weak_encryption",
                        file=_relative_path(file_path, root),
                        line=line_no,
                        snippet=line.strip()[:200],
                        severity="high",
                        confidence=0.85,
                        metadata={"issue": description, "vulnerability": "crypto_misuse", "control_id": "SOC2-CC6.2"}
                    ))
                    break
    
    return findings

